from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import NoAlertPresentException
import time
from datetime import datetime
import pickle  # 파일 저장 및 불러오기를 위해 필요
import tkinter as tk
from tkinter import ttk
import tkinter.filedialog as filedialog
import threading
import pandas as pd
from tkinter import PhotoImage
import openpyxl
from selenium.common.exceptions import NoSuchElementException, TimeoutException
from bs4 import BeautifulSoup
import pyperclip
import random
from ppadb.client import Client as AdbClient
import tkinter.messagebox as messagebox
from selenium import webdriver
import webbrowser

# 전역 변수로 driver 선언
global_driver = None
logged_in_naver_id = None

time1 = random.uniform(0.1, 0.5)
time2 = random.uniform(0.5, 1.5)

def read_login_file():
    global login_file_path  # Declare it as global within the function
    global account_list  

    file_path = filedialog.askopenfilename(filetypes=[("Text files", "*.txt")])
    if file_path:
        login_file_path.set(file_path)  # 파일 경로 저장
        with open(file_path, 'r', encoding='utf-8') as file:

            account_list = []
            for line in file:
                if ',' in line:
                    line = line.strip()  # 줄바꿈 및 공백 제거
                    parts = line.split(',')
                    if len(parts) == 2:
                        account_list.append(parts)
        # 리스트박스 업데이트
        account_listbox.delete(0, tk.END)  # 기존 리스트박스 내용을 지움
        for account in account_list:
            account_listbox.insert(tk.END, account[0])  # 아이디만 리스트박스에 추가


def toggle_airplane_mode():
    if tethering_var.get() == 1:
        print_to_textbox("ip주소를 변경합니다.")
        # Connect to the ADB server
        adb = AdbClient(host="127.0.0.1", port=5037)

        devices = adb.devices()
        if len(devices) == 0:
            print("No device attached")
            quit()

        device = devices[0]
        # Turn on airplane mode
        device.shell("settings put global airplane_mode_on 1")
        device.shell("am broadcast -a android.intent.action.AIRPLANE_MODE --ez state true")
        time.sleep(5)

        device.shell("settings put global airplane_mode_on 0")
        device.shell("am broadcast -a android.intent.action.AIRPLANE_MODE --ez state false")
        time.sleep(20)
        

def setup_chrome_driver():
    chrome_driver_path = "C:\Program Files\Google\Chrome\Application\chrome.exe"
    options = webdriver.ChromeOptions()
    options.add_argument('user-agent=Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36')
    driver = webdriver.Chrome(options=options)

    return driver

# 로그인 버튼 클릭 시 실행되는 함수
def on_login_button_click():
    global global_driver
    
    selected_indices = account_listbox.curselection()
    selected_index = selected_indices[0]
    selected_account = account_list[selected_index]
    naver_id, naver_pw = selected_account  # Unpack the ID and password
    if not global_driver:
        global_driver = setup_chrome_driver()
    thread = threading.Thread(target=login_and_update, args=(naver_id, naver_pw, selected_index))
    thread.daemon = True  # Set as a daemon so it doesn't prevent the app from exiting
    thread.start()


def login_and_update(naver_id, naver_pw, selected_index):
    global global_driver
    global logged_in_naver_id
    toggle_airplane_mode()
    logged_in_naver_id = naver_id
    time.sleep(time1)
    login(global_driver, naver_id, naver_pw)
    update_cafe_list(selected_index, account_list, cafe_listbox)

def login(driver, my_id, my_pw):
    login_url = "https://nid.naver.com/nidlogin.login"
    try:
        driver.get(login_url)
        time.sleep(time2)
        # "switch_btn" 요소를 찾고, 내부의 "span" 요소의 텍스트가 "off"인지 확인합니다.
        switch_btn = driver.find_element(By.CSS_SELECTOR, ".switch_btn")
        switch_status = driver.find_element(By.CSS_SELECTOR, ".switch_btn .blind").text

        # switch_status가 "off"일 경우에만 클릭합니다.
        if switch_status.lower() == "on":
            switch_btn.click()
        time.sleep(time1)
        id_selector = "#id"
        pw_selector = "#pw"
        login_btn_selector = "#log\\.login"
        id_input = driver.find_element(By.CSS_SELECTOR, id_selector)
        pw_input = driver.find_element(By.CSS_SELECTOR, pw_selector)
        login_btn = driver.find_element(By.CSS_SELECTOR, login_btn_selector)
        id_input.click()
        pyperclip.copy(my_id)
        ActionChains(driver).key_down(Keys.CONTROL).send_keys("v").key_up(Keys.CONTROL).perform()
        pw_input.click()
        pyperclip.copy(my_pw)
        ActionChains(driver).key_down(Keys.CONTROL).send_keys("v").key_up(Keys.CONTROL).perform()
        login_btn.click()
        time.sleep(1)    
    except Exception as e:
        driver.refresh()
        time.sleep(time2)
        return login(driver, my_id, my_pw)


#선택된거 로그인하기. 카페 목록가져오기
def update_cafe_list(selected_index, account_list, cafe_listbox):
    global cafe_info_list  # 전역 변수 사용 선언
    global global_driver
    # 카페 목록 가져오기
    cafe_info_list = []
    time.sleep(time1)
    # 카페 목록 페이지로 이동
    global_driver.get('https://section.cafe.naver.com/ca-fe/home/manage-my-cafe/join')
    time.sleep(time2)

    try:
        # 페이지네이션 찾기
        pagination = global_driver.find_element(By.CLASS_NAME, 'SectionPagination')
        page_items = pagination.find_elements(By.CLASS_NAME, 'page_item')
        num_pages = len(page_items)
    except NoSuchElementException:
        # 페이지네이션이 없다면, 한 페이지만 있다고 가정
        num_pages = 1

    current_page = 1
    while current_page <= num_pages:
        req = global_driver.page_source
        soup = BeautifulSoup(req, 'html.parser')

        for tr in soup.find_all('tr'):
            cafe_link = tr.find('a', class_='cafe_name')
            login_nickname = tr.find('span', class_='nick_name')

            if cafe_link and login_nickname:
                cafe_name = cafe_link.get_text(strip=True)
                cafe_url = cafe_link['href']
                cafe_info_list.append((cafe_name, cafe_url, login_nickname.text))  # 카페 이름, URL, 닉네임 저장
                
        if current_page < num_pages:
            try:
                next_page_number = current_page + 1
                next_page_btn = WebDriverWait(global_driver, 1).until(
                    EC.element_to_be_clickable((By.XPATH, f'//a[contains(@class, "page_item") and text()="{next_page_number}"]'))
                )
                next_page_btn.click()
                time.sleep(time1)
                current_page += 1
            except TimeoutException:
                print_to_textbox("가입된 카페 리스트 추출이 완료되었습니다.")  # 외부 정의 필요
                break
        else:
            break
    cafe_listbox.delete(0, 'end')  # 리스트박스의 기존 항목을 모두 삭제
    for cafe_name, _, _ in cafe_info_list:
        cafe_listbox.insert('end', cafe_name)  # 카페 이름을 리스트박스에 추가


def filter_and_display_cafes(search_term):
    cafe_listbox.delete(0, tk.END)  # 기존 리스트박스 내용을 지움
    filtered_cafes = [cafe for cafe in cafe_info_list if search_term.lower() in cafe[0].lower()]
    for cafe in filtered_cafes:
        cafe_listbox.insert(tk.END, cafe[0])  # 필터링된 카페 이름을 리스트박스에 추가

def add_placeholder_cafe(entry, placeholder, callback=None):
    """Entry 위젯에 플레이스홀더와 선택적 콜백 함수를 추가하는 함수"""
    entry.insert(0, placeholder)
    entry.config(fg='grey')
    entry.bind("<FocusIn>", lambda event: on_entry_click(event, placeholder))
    entry.bind("<FocusOut>", lambda event: on_focusout(event, placeholder))

    if callback:
        # 사용자 입력에 반응하여 콜백 함수 호출
        entry.bind("<KeyRelease>", lambda event: callback())

def on_entry_click(event, placeholder):
    """Entry 위젯 클릭 시 실행되는 이벤트 핸들러"""
    if event.widget.get() == placeholder:
        event.widget.delete(0, "end")
        event.widget.insert(0, '')
        event.widget.config(fg='black')

def on_focusout(event, placeholder):
    """Entry 위젯 포커스가 사라졌을 때 실행되는 이벤트 핸들러"""
    if event.widget.get() == '':
        event.widget.insert(0, placeholder)
        event.widget.config(fg='grey')

def on_cafe_select_and_update_treeview():
    current_entries = tree.get_children()
    row_number = len(current_entries) + 1  # Start from the next number

    selected_indices = cafe_listbox.curselection()
    for i in selected_indices:
        cafe_name = cafe_listbox.get(i)
        for cafe in cafe_info_list:
            if cafe[0] == cafe_name:
                cafe_url, login_nickname = cafe[1], cafe[2]
                new_row_id = tree.insert("", tk.END, values=(row_number, logged_in_naver_id, cafe_name, cafe_url, login_nickname))
                tree.selection_set(new_row_id)
                tree.see(new_row_id)
                row_number += 1

def all_cafe_select():
    if select_all_var.get() == 1:
        cafe_listbox.selection_set(0, tk.END)
    if select_all_var.get() == 0:
        cafe_listbox.selection_clear(0, tk.END)


def delete_selected_item():
    selected_items = tree.selection()  # 현재 선택된 모든 행의 ID
    for selected_item in selected_items:
        tree.delete(selected_item)
    
    # 행 삭제 후 행 번호 재정렬
    for index, item in enumerate(tree.get_children(), start=1):
        tree.set(item, '#1', str(index))  # 첫 번째 열('#1')을 새로운 순서 번호로 업데이트

# 모든 행을 삭제하는 함수
def all_delete_selected_item():
    for item in tree.get_children():
        # 각 항목을 삭제합니다.
        tree.delete(item)

#게시판추출
def get_board_list(driver, cafe_url):
    # 해당 카페 URL로 이동
    driver.get(cafe_url)
    time.sleep(time2)

    # 현재 페이지의 HTML 파싱
    req = driver.page_source
    soup = BeautifulSoup(req, 'html.parser')

    # 게시판 목록 추출
    board_menus = []
    cafe_menu_lists = soup.select("ul.cafe-menu-list")
    for menu_list in cafe_menu_lists:
        list_items = menu_list.select("li")
        for item in list_items:
            link_text = item.select_one("a.gm-tcol-c")
            if link_text:
                board_menus.append(link_text.get_text(strip=True))  
    return board_menus

board_list = []  # 전역 변수로 현재 게시판 목록을 저장
def on_cafe_select():
    global board_list
    # 현재 선택된 행의 ID를 가져옵니다.
    selected_item = tree.focus()
    
    # 선택된 행의 데이터를 가져옵니다.
    item_data = tree.item(selected_item, 'values')
    
    # 카페 URL을 가져옵니다.
    cafe_url = item_data[3]  # 4번째 열에 URL이 있다고 가정

    # 게시판 목록을 가져옵니다.
    board_list = get_board_list(global_driver, cafe_url)

    # 콤보박스 업데이트
    board_combobox['values'] = board_list


def filter_and_display_boards(search_term):
    global board_list  # 전역 변수 사용 선언

    # 검색어가 비어있는 경우 전체 게시판 목록을 표시
    if not search_term.strip():
        board_combobox['values'] = board_list
    else:
        # 검색어에 해당하는 게시판만 필터링하여 표시
        filtered_boards = [board for board in board_list if search_term.lower() in board.lower()]
        board_combobox['values'] = filtered_boards

def add_placeholder_board(entry, placeholder, callback=None):
    """Entry 위젯에 플레이스홀더와 선택적 콜백 함수를 추가하는 함수"""
    entry.insert(0, placeholder)
    entry.config(fg='grey')
    entry.bind("<FocusIn>", lambda event: on_entry_click(event, placeholder))
    entry.bind("<FocusOut>", lambda event: on_focusout(event, placeholder))

    if callback:
        # 사용자 입력에 반응하여 콜백 함수 호출
        entry.bind("<KeyRelease>", lambda event: callback())

def on_entry_click(event, placeholder):
    """Entry 위젯 클릭 시 실행되는 이벤트 핸들러"""
    if event.widget.get() == placeholder:
        event.widget.delete(0, "end")  # 기존 플레이스홀더 텍스트 삭제
        event.widget.config(fg='black')  # 텍스트 색상을 검정색으로 변경

def on_focusout(event, placeholder):
    """Entry 위젯 포커스가 사라졌을 때 실행되는 이벤트 핸들러"""
    if event.widget.get() == '':
        event.widget.insert(0, placeholder)  # 플레이스홀더 텍스트 재삽입
        event.widget.config(fg='grey')  # 텍스트 색상을 회색으로 변경


# 글, 댓글 게시판 업데이트
def update_treeview_for_selected_item(action):
    selected_board = board_combobox.get()
    selected_items = tree.selection()

    if selected_items:  # 선택된 항목이 있는지 확인
        item_to_update = selected_items[0]
        current_values = list(tree.item(item_to_update, 'values'))

        # 현재 값의 리스트가 7개 미만일 경우, 빈 값으로 채웁니다.
        while len(current_values) < 12:
            current_values.append("")

        # 'action' 인자에 따라 새로운 값으로 업데이트합니다.
        if action == "post":
            # 'post' 업데이트는 6번째 위치에 값을 할당합니다 (인덱스는 5).
            current_values[5] = selected_board
        elif action == "review":
            # 'review' 업데이트는 7번째 위치에 값을 할당합니다 (인덱스는 6).
            current_values[6] = selected_board
            
        # 트리뷰 항목을 새로운 값으로 업데이트합니다.
        tree.item(item_to_update, values=current_values)

# 버튼의 command에 사용할 함수 정의
def handle_post_button_click():
    update_treeview_for_selected_item("post")

def handle_review_button_click():
    update_treeview_for_selected_item("review")

def add_columns_with_spinboxes(tree):
    columns = (
        "번호", "아이디", "카페명", "카페주소", "닉네임", "글게시판", "댓글게시판",
        "방문수", "댓글수", "게시글수", "딜레이(분)", "작업"
    )
    tree['columns'] = columns
    for col in columns:
        tree.heading(col, text=col)
        if col in ("번호", "카페주소","닉네임", "방문수", "댓글수", "게시글수", "작업"):
            tree.column(col, width=50)
        else:
            tree.column(col, width=80)
        
    # Treeview 위젯의 특정 셀 클릭 시 실행될 콜백 함수를 바인딩
    tree.bind('<ButtonRelease-1>', lambda event: on_treeview_click(event, tree))


def on_treeview_click(event, tree):
    # Here you'll pop up a spinbox when a cell in columns 6-9 is clicked
    region = tree.identify("region", event.x, event.y)
    if region == "cell":
        column = tree.identify_column(event.x)
        row = tree.identify_row(event.y)
        if column in ('#8', '#9', '#10', '#11'):  # Target the columns with spinboxes
            spinbox_popup(event.x_root, event.y_root, tree, row, column)

def spinbox_popup(x, y, tree, row, column):
    # Create a toplevel window
    popup = tk.Toplevel()
    popup.wm_overrideredirect(True)
    popup.geometry(f"+{x}+{y}")

    # Create Spinbox and set focus
    spinbox = tk.Spinbox(popup, from_=0, to=99999, width=5)
    spinbox.focus_force()
   
    # Get the current value of the cell and place it in the Spinbox
    current_value = tree.set(row, column)
    spinbox.delete(0, tk.END)
    spinbox.insert(0, current_value)

    def on_spinbox_enter(event=None):
        # Update Treeview cell value
        tree.set(row, column, spinbox.get())
        popup.destroy()

    spinbox.bind('<Return>', on_spinbox_enter)
    spinbox.bind('<FocusOut>', on_spinbox_enter)
    spinbox.pack()

def update_all_rows_with_entry_values():
    # 각 열에 대한 입력 값 가져오기
    visit_count = visit_count_entry.get()
    comment_count = comment_count_entry.get()
    post_count = post_count_entry.get()
    delay_time = delay_time_entry.get()
    
    # 입력값 검증 (예시로 숫자인지 확인, 실제 사용시 더 세밀한 검증 필요)
    if not all(value.isdigit() for value in [visit_count, comment_count, post_count, delay_time]):
        messagebox.showerror("입력 오류", "모든 값은 숫자여야 합니다.")  # 에러 메시지 출력 예시
        return

    # 트리뷰의 모든 행을 순회하면서 값을 업데이트
    for item in tree.get_children():
        tree.set(item, "#8", visit_count)
        tree.set(item, "#9", comment_count)
        tree.set(item, "#10", post_count)
        tree.set(item, "#11", delay_time)


def on_entry_click(event, placeholder):
    """Entry 위젯 클릭 시 실행되는 이벤트 핸들러"""
    if event.widget.get() == placeholder:
        event.widget.delete(0, "end")  # 내용 삭제
        event.widget.insert(0, '')  # 빈 문자열 삽입
        event.widget.config(fg='black')  # 글씨 색상 변경

def on_focusout(event, placeholder):
    """Entry 위젯 포커스가 사라졌을 때 실행되는 이벤트 핸들러"""
    if event.widget.get() == '':
        event.widget.insert(0, placeholder)
        event.widget.config(fg='grey')

def add_placeholder_to(entry, placeholder):
    """Entry 위젯에 플레이스홀더를 추가하는 함수"""
    entry.insert(0, placeholder)
    entry.config(fg='grey')
    entry.bind("<FocusIn>", lambda event, placeholder=placeholder: on_entry_click(event, placeholder))
    entry.bind("<FocusOut>", lambda event, placeholder=placeholder: on_focusout(event, placeholder))

def save_treeview_data():
    """트리뷰 데이터를 파일로 저장합니다."""
    data = [(tree.item(item)['values']) for item in tree.get_children()]
    filepath = filedialog.asksaveasfilename(defaultextension=".pkl", filetypes=[("Pickle files", "*.pkl")])
    if filepath:
        with open(filepath, 'wb') as outfile:
            pickle.dump(data, outfile)
        print_to_textbox(f"데이터가 저장되었습니다: {filepath}")

def load_treeview_data():
    """파일로부터 트리뷰 데이터를 불러와 트리뷰에 표시합니다."""
    filepath = filedialog.askopenfilename(filetypes=[("Pickle files", "*.pkl")])
    if filepath:
        with open(filepath, 'rb') as infile:
            data = pickle.load(infile)
        for item in data:
            tree.insert("", tk.END, values=item)
        print_to_textbox(f"데이터가 불러와졌습니다: {filepath}")


#실행버튼이후작업
def find_password_for_id(id, file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        for line in file:
            parts = line.strip().split(',')
            if parts[0] == id:
                return parts[1]  # ID에 해당하는 비밀번호 반환
    return None  # 비밀번호를 찾지 못한 경우


def load_comments_from_file(file_paths):
    comments = []
    for file_path in file_paths:  # Iterate over each file path
        try:
            with open(file_path, 'r', encoding='utf-8') as file:
                comments.extend([line.strip() for line in file.readlines()])
        except FileNotFoundError:
            print(f"File not found: {file_path}")
    return comments
# 파일 선택 버튼의 기능을 정의하는 함수
def load_post_contents():
    file_path = filedialog.askopenfilename(filetypes=[("Excel files", "*.xlsx")])
    if file_path:
        # 여기서 파일 경로를 사용하여 필요한 작업을 수행합니다.
        cafe_post_file_path.set(file_path)
        post_contents_label.config(text=file_path)
    pass
def load_comment_contents():
    file_path = filedialog.askopenfilename(filetypes=[("Text files", "*.txt")])
    if file_path:
        review_file_path.set(file_path)  # Ensure this is a string
        comment_contents_label.config(text=file_path)
    pass

# # 게시글 내의 댓글을 파싱하는 함수
# def get_comments_from_post(driver):
#     html = global_driver.page_source
#     soup = BeautifulSoup(html, 'html.parser')
#     comments_data = []
#     comments = soup.find_all('li', class_='CommentItem')
#     for comment in comments:
#         try:
#             nickname = comment.find('a', class_='comment_nickname').text.strip()
#             comment_text = comment.find('span', class_='text_comment').text.strip()
#             comments_data.append({'nickname': nickname, 'content': comment_text})
#         except AttributeError:
#             continue  # 해당 요소가 없으면 건너뛰기
#     return comments_data

# def is_duplicate_comment(nickname, comment_text, file_comments_list):
#     # 현재 페이지의 댓글과 파일의 댓글 목록을 비교
#     return any(
#         comment_text == c
#         for c in file_comments_list
#     )
#     return comment_text in file_comments_list

# def is_duplicate_comment(login_nickname, comment_nickname, comment_text, file_comments_list):
#     # 로그인한 사용자의 닉네임과 댓글 작성자의 닉네임이 같을 때만 댓글 내용을 중복 검사
#     if login_nickname == comment_nickname:
#         return comment_text in file_comments_list
#     return False

def process_review(global_driver, cafe_url, review_menu, file_comments_list, 댓글작성횟수, login_nickname, review_path):
    global_driver.get(cafe_url)
    # 이전 댓글들을 가져옵니다.
    #existing_comments = get_comments_from_post(global_driver)
 
    # 게시판찾고 클릭
    req = global_driver.page_source  
    soup = BeautifulSoup(req, 'html.parser')
    cafe_menu_lists = soup.select("ul.cafe-menu-list > li > a")
    for menu in cafe_menu_lists:
        if review_menu in menu.text:
            review_menu_link = menu['href']
            global_driver.get(cafe_url + review_menu_link)
            break

    time.sleep(1)  # 페이지 로드 대기 후 나머지 코드 실행
    현재댓글수 = 0  # 작성한 댓글 수
    current_page = 1  # 현재 페이지 번호
    global_driver.switch_to.frame("cafe_main")
   
    while 현재댓글수 < 댓글작성횟수:
        posts = global_driver.find_elements(By.CSS_SELECTOR, "#main-area > div:nth-child(4) > table > tbody > tr > td.td_article > div.board-list > div > a.article")
        # 게시글 클릭 횟수 계산
        게시글클릭횟수 = min(len(posts), 댓글작성횟수 - 현재댓글수)
        i = 0  # 게시글 인덱스 초기화
        for i in range(len(posts)):
            post = posts[i]
            if i >= len(posts):
                break  # 게시글 목록이 예상보다 짧은 경우 종료합니다.
           
            if 현재댓글수 >= 댓글작성횟수:
                break
            post_link = post.get_attribute('href')
            global_driver.execute_script("window.open(arguments[0]);", post_link)
            global_driver.switch_to.window(global_driver.window_handles[1])
            time.sleep(time2)
            
            
            global_driver.switch_to.frame("cafe_main")
            time.sleep(time1)
            try:
                # "댓글 달기 불가" 버튼을 찾습니다. 요소가 없으면 NoSuchElementException 예외가 발생합니다.
                global_driver.find_element(By.CSS_SELECTOR, "a.button_comment.not_allowed")
                time.sleep(time1)
                print_to_textbox(f"'{cafe_name}' 카페에서 글쓰기 권한이 없습니다. 다음 카페로 이동합니다.")
                global_driver.close()  # 현재 탭 닫기
                time.sleep(time1)
                global_driver.switch_to.window(global_driver.window_handles[0])  # 원래 탭으로 전환
                global_driver.switch_to.frame("cafe_main")
                continue
            except NoSuchElementException:
                pass
            # Correct call
            file_comments_list = load_comments_from_file([review_path])

            # 중복 검사 및 댓글 데이터 수집
            html = global_driver.page_source
            soup = BeautifulSoup(html, 'html.parser')
            comments = soup.find_all('li', class_='CommentItem')
            is_duplicate = False

            for comment in comments:
                try:
                    nickname = comment.find('a', class_='comment_nickname').text.strip()
                    # 로그인한 사용자가 작성한 댓글 중 파일 목록에 있는 댓글이면 중복으로 판단
                    if nickname == login_nickname:
                        is_duplicate = True
                        break  # 중복된 댓글을 찾으면 더 이상 검사하지 않고 반복문 탈출
                except AttributeError:
                    continue  # 해당 요소가 없으면 건너뛰기

            #is_duplicate = any(is_duplicate_comment(login_nickname, comment_text, file_comments_list) for comment in existing_comments)
            if is_duplicate:
                global_driver.close()  # 현재 탭 닫기
                global_driver.switch_to.window(global_driver.window_handles[0])  # 원래 탭으로 전환
                global_driver.switch_to.frame("cafe_main")
                continue


                # file_comments_list에서 랜덤 댓글 선택
            time.sleep(time1)
            try:
                comment_input_box = WebDriverWait(global_driver, 2).until(
                    EC.presence_of_element_located((By.CSS_SELECTOR, "textarea.comment_inbox_text"))
                )
                global_driver.execute_script("arguments[0].scrollIntoView(true);", comment_input_box)  # 요소가 보이도록 스크롤
                time.sleep(time1)  # 스크롤 후 잠시 대기
                # 댓글 입력 상자에 텍스트 입력
                comment_input_box.click()  # 댓글 입력 상자 클릭
                time.sleep(time1)
            except NoSuchElementException:
                global_driver.close()  # 현재 탭 닫기
                global_driver.switch_to.window(global_driver.window_handles[0])  # 원래 탭으로 전환
                global_driver.switch_to.frame("cafe_main")
                continue
            
            comment_input_box.clear()  # 기존 텍스트 제거
            time.sleep(time1)
            random_comment = random.choice(file_comments_list)
            comment_input_box.send_keys(random_comment)  # 텍스트 입력

            # '등록' 버튼 찾기 및 클릭
            submit_button = WebDriverWait(global_driver, 1).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "a.btn_register"))
            )
            submit_button.click()
            현재댓글수 += 1
            time.sleep(10)
           
            global_driver.close()  # 새 탭 닫기
            global_driver.switch_to.window(global_driver.window_handles[0])  # 원래 탭으로 전환
            global_driver.switch_to.frame("cafe_main")
            time.sleep(time2)
           
        # 다음 페이지로 이동
        if 현재댓글수 < 댓글작성횟수:
            if current_page % 10 == 0 and current_page < total_pages:
                next_button = driver.find_element(By.CSS_SELECTOR, '#main-area > div.prev-next > a.pgR')
                next_button.click()
            elif current_page < total_pages:
                if current_page <= 10:
                    next_page_index = (current_page % 10) + 1
                else:
                    next_page_index = (current_page % 10) + 2
                next_page_selector = f'#main-area > div.prev-next > a:nth-child({next_page_index + 1})'  # +1 because nth-child(2) is the first page
                next_page_button = driver.find_element(By.CSS_SELECTOR, next_page_selector)
                next_page_button.click()  # Directly click on the identified button
            current_page += 1
    return 현재댓글수
def sanitize_sheet_title(title):
    invalid_chars = ['[', ']', ':', '*', '?', '/', '\\']
    for char in invalid_chars:
        title = title.replace(char, '')
    return title

def cafe_post(global_driver, cafe_url, cafe_name, post_menu, target_sheet, source_wb, source_sheet, cafe_post_file_path):
    게시글작성성공 = False
    상태 = ''
    global_driver.get(cafe_url)
    time.sleep(time2)

    post_menu_found = False
    cafe_menu_lists = global_driver.find_elements(By.CSS_SELECTOR, "ul.cafe-menu-list > li > a")
    for menu in cafe_menu_lists:
        if post_menu in menu.text:
            try:
                global_driver.execute_script("arguments[0].dispatchEvent(new MouseEvent('click', {bubbles: true, cancelable: true}));", menu)
                post_menu_found = True
                break
            except Exception as e:
                print_to_textbox(f"JavaScript 클릭 오류: {e}")
                return False, '건너뜀'
    time.sleep(time1)

    #글쓰기버튼
    write_button = WebDriverWait(global_driver, 1).until(
        EC.presence_of_element_located((By.CSS_SELECTOR, "a._rosRestrict"))
    )
    time.sleep(time1)
    ActionChains(global_driver).key_down(Keys.CONTROL).click(write_button).key_up(Keys.CONTROL).perform()
    global_driver.switch_to.window(global_driver.window_handles[1])
    time.sleep(time2)
    
    
    try:
        # WebDriverWait을 사용하여 알림창이 나타나는지 최대 2초 동안 기다립니다.
        alert = WebDriverWait(global_driver, 2).until(EC.alert_is_present())
        
        # 알림창이 존재하면, 아래 코드가 실행됩니다.
        alert.accept()  # 알림창의 확인 버튼을 누릅니다.
        상태 = '건너뜀'  # '건너뜀'으로 작업 상태를 표시합니다.
        global_driver.switch_to.window(global_driver.window_handles[0])  # 원래 탭으로 전환
        
    except TimeoutException:
        pass
    if 상태 == '건너뜀':
        return False, '건너뜀'

    if "cafe_main" in global_driver.page_source:
        global_driver.switch_to.frame("cafe_main")
        time.sleep(time2)
        global_driver.find_element(By.CSS_SELECTOR, "a.BaseButton--skinGray")
        global_driver.find_element(By.XPATH, "//p[contains(text(), '등급이 되시면 읽기가 가능한 게시판 입니다.')]")
        print_to_textbox(f"'{cafe_name}' 카페에서 글쓰기 권한이 없습니다. 다음 카페로 이동합니다.")
        global_driver.close()  # 현재 탭 닫기
        global_driver.switch_to.window(global_driver.window_handles[0])  # 원래 탭으로 전환
        return False, '건너뜀'
    
    column_a_values_source = [cell.value for cell in source_sheet['A'] if cell.value]
    column_a_values_target = [cell.value for cell in target_sheet['A'] if cell.value]
    non_duplicate_values = list(set(column_a_values_source) - set(column_a_values_target))
    
    if non_duplicate_values:
        random_value = random.choice(non_duplicate_values)
        for row in source_sheet.iter_rows(min_row=1, max_col=2, max_row=source_sheet.max_row):
            if row[0].value == random_value:
                max_row = target_sheet.max_row + 1
                target_sheet.cell(row=max_row, column=1, value=row[0].value)  # 제목
                target_sheet.cell(row=max_row, column=2, value=row[1].value)  # 본문
                file_path_to_save = cafe_post_file_path.get()  # 수정된 부분
                source_wb.save(file_path_to_save)
                time.sleep(time1)
                global_driver.switch_to.default_content()
                time.sleep(time1)
                title_input = WebDriverWait(global_driver, 1).until(
                    EC.presence_of_element_located((By.XPATH, "//textarea[@placeholder='제목을 입력해 주세요.']"))
                )
                title = target_sheet.cell(row=max_row, column=1).value
                pyperclip.copy(str(title))
                title_input.click()
                ActionChains(global_driver).key_down(Keys.CONTROL).send_keys('v').key_up(Keys.CONTROL).perform()
                time.sleep(time1)
                # Targeting the focused placeholder within the text module of a component content
                content_input = global_driver.find_element(By.CSS_SELECTOR, "div.se-component-content .se-placeholder.__se_placeholder.se-ff-system.se-fs15.se-placeholder-focused")

                #content_input = global_driver.find_element(By.CSS_SELECTOR, "div.se-component-content div.se-module-text")
                time.sleep(time1)
                
                content = target_sheet.cell(row=max_row, column=2).value
                
                pyperclip.copy(str(content))
                time.sleep(time1)
                content_input.click()
                
                time.sleep(time1)
                ActionChains(global_driver).key_down(Keys.CONTROL).send_keys('v').key_up(Keys.CONTROL).perform()
                time.sleep(time1)
                try:
                    submit_button_selector = "#app > div > div > section > div > div.WritingHeader > div > a"
                    submit_button = global_driver.find_element(By.CSS_SELECTOR, submit_button_selector)
                    global_driver.execute_script("arguments[0].click();", submit_button)
                    time.sleep(time1)  # 게시글 제출 후 대기

                    global_driver.close()  # 현재 탭 닫기
                    global_driver.switch_to.window(global_driver.window_handles[0])  # 원래 탭으로 전환

                    print_to_textbox(f"글 작성 완료: 카페명 '{cafe_name}', 게시물 제목 '{title}'")
                except Exception as e:
                    print_to_textbox(f"글 작성 중 오류 발생: {e}")
                    return False, '건너뜀'
    return True, '진행중'   # 성공적으로 게시글이 작성되었는지 반환


def get_selected_id_from_treeview():
    selected_item = tree.selection()[0]  # 첫 번째 선택된 항목
    id_value = tree.item(selected_item, 'values')[0]  # 'values'의 첫 번째 요소가 ID라고 가정
    return id_value
   
def print_to_textbox(message):
    text_area.insert(tk.END, message + "\n")
    text_area.see(tk.END)  # 스크롤 자동 이동
   
def update_treeview_selection(row_id):
    """Update the treeview selection and ensure the row is visible."""
    if not tree.exists(row_id):  # Check if the row_id still exists to avoid errors
        return
    tree.selection_set(row_id)
    tree.see(row_id)


# 주요 작업을 수행하는 함수
def run_main_in_thread(cafe_post_path, review_path, id, pw):
    empty_boards_found  = False
    # cafe_post_path와 review_path가 비어 있는지 확인
    if not cafe_post_path or not review_path:
        messagebox.showwarning("확인 요청", "게시글과 댓글 파일을 불러오고 다시 시도하세요.")
        return  # 함수 실행 중지

    # 비어 있는 게시판이 있는지 확인

    for row_id in tree.get_children():
        row_data = tree.item(row_id, 'values')
        post_board, comment_board = row_data[5], row_data[6]
        if not post_board or not comment_board:
            empty_boards_found = True
            break
    if empty_boards_found:
        # 비어 있는 게시판이 있는 경우 사용자에게 확인 요청
        response = messagebox.askokcancel("확인 요청", "글게시판 또는 댓글게시판 정보가 비어 있으면 건너뜁니다. 계속하시겠습니까?")
        if response:
            # 사용자가 '확인'을 선택한 경우, 비어 있는 게시판이 있는 행에 '건너뜀' 설정
            for row_id in tree.get_children():
                row_data = tree.item(row_id, 'values')
                post_board, comment_board = row_data[5], row_data[6]
                if not post_board or not comment_board:
                    tree.set(row_id, '#12', '건너뜀')  # 비어 있는 게시판이 있는 행에만 '건너뜀' 설정
        else:
            # 사용자가 '취소'를 선택한 경우, 작업을 중지합니다.
            return
    # Check for empty fields in the Treeview
    for row_id in tree.get_children():
        row_data = tree.item(row_id, 'values')
        방문수 = int(row_data[7])  # 8번째 열 (0-based index)
        게시글수 = int(row_data[9])  # 10번째 열 (0-based index)
        if 게시글수 > 방문수:
            messagebox.showerror("입력 오류", f"게시글 수({게시글수})는 방문 수({방문수})보다 많을 수 없습니다.")
            return
    # If no empty fields are found, proceed with running the main function in a thread
    thread = threading.Thread(target=remain, args=(cafe_post_path, review_path, id, pw))
    thread.start()


def remain(cafe_post_path, review_path, id, pw):
    global global_driver
    source_wb = openpyxl.load_workbook(cafe_post_path)
    file_comments_list = load_comments_from_file([review_path])

    previous_id = None
    last_visit_time = {}
    cafe_status = {}

    # 초기화 및 '진행중' 상태 설정
    for row_id in tree.get_children():
        tree.set(row_id, column='작업', value='진행중')
    react = True
    while react:
        react = False
        for row_id in tree.get_children():
            row_data = tree.item(row_id, 'values')
            # 글게시판과 댓글게시판 값이 빈칸인지 확인
            post_menu, review_menu = row_data[5], row_data[6]
            if not post_menu or not review_menu:
                tree.set(row_id, column='작업', value='건너뜀')
                continue  # 이 행의 처리를 건너뜁니다.
            
            _, cafe_id, cafe_name, cafe_url, login_nickname, post_menu, review_menu, target_visits, target_comments, target_posts, visit_delay_str, 작업 = row_data
            target_visits, target_comments, target_posts = map(int, [target_visits, target_comments, target_posts])
            visit_delay = int(visit_delay_str) if visit_delay_str else 0  # 방문 딜레이를 정수로 처리

            # 이미 '완료'된 카페는 건너뛰기
            if 작업  == '완료':
                continue
            if 작업  == '건너뜀':
                continue
 
            # 카페명과 아이디를 튜플로 결합
            cafe_key = (cafe_name, cafe_id)

            if cafe_key in last_visit_time and (time.time() - last_visit_time[cafe_key]) < visit_delay * 60:
                continue  # 방문 간격이 충분하지 않은 경우 건너뛰기

            # 카페 상태 정보 초기화
            if cafe_key not in cafe_status:
                cafe_status[cafe_key] = {

                    '방문수': 0, 
                    '댓글수': 0, 
                    '게시글수': 0, 
                    '목표방문수': target_visits,  # '방문수' 대신 'target_visits' 사용
                    '목표댓글수': target_comments,  # '댓글수' 대신 'target_comments' 사용
                    '목표게시글수': target_posts  # '게시글수' 대신 'target_posts' 사용
                }
            if previous_id != cafe_id:
                if global_driver:
                    global_driver.quit()
                    
                toggle_airplane_mode()
                
                global_driver = setup_chrome_driver()
                # Find password and log in
                login_file_path_value = login_file_path.get()
                password = find_password_for_id(cafe_id, login_file_path_value)
                login(global_driver, cafe_id, password)
                
            # 카페 방문
            root.after(0, update_treeview_selection, row_id)
            global_driver.get(cafe_url)
            cafe_status[cafe_key]['방문수'] += 1

            # 남은 댓글 수를 계산
            remaining_comments = target_comments - cafe_status[cafe_key]['댓글수']

            # 남은 방문 수 계산 (+1은 현재 방문 포함)
            remaining_visits = target_visits - cafe_status[cafe_key]['방문수'] + 1

            # 댓글 분배 로직 개선
            if remaining_comments > 0 and cafe_status[cafe_key]['방문수'] <= target_visits:
                # 마지막 방문인 경우 남은 모든 댓글 작성
                if cafe_status[cafe_key]['방문수'] == target_visits:
                    댓글작성횟수 = remaining_comments
                else:
                    # 남은 방문 수를 고려하여 이번 방문에서 작성할 댓글 수 결정
                    # 예를 들어, 남은 댓글 수를 남은 방문 수로 나누어 각 방문마다 균등하게 분배할 수 있도록 계획
                    expected_comments_per_visit = remaining_comments / remaining_visits
                    # 실제 작성할 댓글 수는 예상치를 기준으로 랜덤 결정 (예시)
                    댓글작성횟수 = random.randint(0, max(int(expected_comments_per_visit), remaining_comments))
  
                댓글작성횟수 = process_review(global_driver, cafe_url, review_menu, file_comments_list, 댓글작성횟수, login_nickname, review_file_path.get())
                cafe_status[cafe_key]['댓글수'] += 댓글작성횟수
            pass

            #if target_posts > cafe_status[cafe_key]['게시글수']:
            
            # 목표 게시글 수와 목표 방문 수를 기반으로 남은 게시글과 방문 수에 대한 로직을 계산
            remaining_posts = target_posts - cafe_status[cafe_key]['게시글수']
            remaining_visits = target_visits - cafe_status[cafe_key]['방문수'] +1

                
            # 방문마다 가능한 게시글 작성 여부를 결정
            if remaining_visits > 0 and remaining_posts > 0:
                # 현재 방문에서 게시글 작성 여부 결정
                # 이번 방문에서 게시글을 작성할 확률: 남은 게시글 수 / 남은 방문 수
                write_post_chance = remaining_posts / float(remaining_visits)
                write_post = random.random() < write_post_chance
            else:
                write_post = False

            if write_post:
                # Truncate the title if it's longer than 31 characters
                if len(cafe_name) > 31:
                    truncated_cafe_name = cafe_name[:31]
                else:
                    truncated_cafe_name = cafe_name

                truncated_cafe_name = sanitize_sheet_title(truncated_cafe_name)

                # Now you can safely create a new sheet with the sanitized title
                if truncated_cafe_name not in source_wb.sheetnames:
                    target_sheet = source_wb.create_sheet(title=truncated_cafe_name)
                else:
                    target_sheet = source_wb[truncated_cafe_name]
                try:
                    file_path_to_save = cafe_post_file_path.get()
                    source_wb.save(file_path_to_save)
                except Exception as e:
                    print_to_textbox(f"파일 저장 오류 : {e}")
                sheetnames = source_wb.sheetnames
                source_sheet = source_wb[sheetnames[0]]
                
                게시글작성성공, 작업상태 = cafe_post(global_driver, cafe_url, cafe_name, post_menu, target_sheet, source_wb, source_sheet, cafe_post_file_path)
                tree.set(row_id, column='작업', value=작업상태)

                
                if 게시글작성성공:
                    cafe_status[cafe_key]['게시글수'] += 1
            time.sleep(time2)
            previous_id = cafe_id
            global_driver.get("https://www.naver.com")
            last_visit_time[cafe_key] = time.time()
            # Get the current time in the desired format
            formatted_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            print_to_textbox(f"[{formatted_time}] [{cafe_name}] 카페 현황: 방문수 {cafe_status[cafe_key]['방문수']}, 댓글수 {cafe_status[cafe_key]['댓글수']}, 게시글수 {cafe_status[cafe_key]['게시글수']}")

            if (cafe_status[cafe_key]['방문수'] >= target_visits and 
                cafe_status[cafe_key]['댓글수'] >= target_comments and 
                cafe_status[cafe_key]['게시글수'] >= target_posts):
                tree.set(row_id, column='작업', value='완료')
                print_to_textbox(f"완료 : {cafe_id} - {cafe_name}")
            else:
                pass

        for row_id in tree.get_children():
            작업 = tree.item(row_id, 'values')[-1]  # 마지막 칼럼(작업 상태)를 가져옴
            if 작업 == '진행중':
                react = True  # '진행중' 상태가 하나라도 있으면 다시 순회
                break  # '진행중' 상태를 찾았으므로 더 이상의 검사는 필요 없음

        # 모든 카페 작업이 완료되었을 때의 처리
        if not react:
            print_to_textbox("모든 카페의 작업이 완료되었습니다.")
            global_driver.quit()
            source_wb.save(cafe_post_path)

def main():
    global login_file_path
    global account_listbox
    global tethering_var
    global naver_id
    global naver_pw
    global cafe_post_file_path
    global review_file_path
    global search_cafe_var
    global select_all_var
    global search_board_var
    global text_area 
    global cafe_listbox
    global tree
    global board_combobox
    global post_contents_label
    global comment_contents_label
    global cafe_id
    global password
    global root
    global visit_count_entry
    global comment_count_entry
    global post_count_entry
    global delay_time_entry
    global visit_delay
    global source_sheet
    global target_sheet
    global file_path_to_save
    
    # Tkinter 창 설정
    root = tk.Tk()
    root.title("카페등업프로그램")
    root.geometry("1100x900")  # 전체 창 크기 조정

    # Now create StringVar objects
    cafe_post_file_path = tk.StringVar()
    review_file_path = tk.StringVar()
    user_id = tk.StringVar()
    user_pw = tk.StringVar()
    login_file_path = tk.StringVar()

    # PanedWindow 설정
    paned_window = tk.PanedWindow(root, orient=tk.HORIZONTAL)
    paned_window.pack(fill=tk.BOTH, expand=True)

    # 왼쪽 프레임 설정
    frame_left = tk.Frame(paned_window)
    paned_window.add(frame_left, width=200)

    # 오른쪽 프레임 설정
    frame_right = tk.Frame(paned_window)
    paned_window.add(frame_right, width=20)


    reference_video_button = tk.Button(frame_left, text="사용 방법", command=lambda: webbrowser.open("https://gossamer-legal-510.notion.site/b6ecfed0c9e04e23b970bbc6d6956d30"))
    reference_video_button.pack(side=tk.TOP, fill=tk.X)

    login_frame = ttk.LabelFrame(frame_left, text="로그인 정보")
    login_frame.pack(fill=tk.X, padx=10, pady=5)

    # 왼쪽 프레임 내용 설정 및 buttons_frame 정의
    file_button = tk.Button(login_frame, text="파일", command=read_login_file)
    file_button.pack()

    account_listbox = tk.Listbox(login_frame)
    account_listbox.pack()

    # 체크박스 상태를 저장할 변수
    tethering_var = tk.IntVar()

    # 체크박스 추가
    tethering_checkbox = tk.Checkbutton(login_frame, text="자동 테더링모드", variable=tethering_var)
    tethering_checkbox.pack(pady=5)

    # 로그인 버튼에 대한 클릭 이벤트 연결
    login_button = tk.Button(login_frame, text="로그인", command=on_login_button_click)
    login_button.pack()

    tk.Label(frame_left).pack()


    cafe_frame = ttk.LabelFrame(frame_left, text="카페 셋팅")
    cafe_frame.pack(fill=tk.BOTH,padx=10, pady=5)

    search_cafe_var = tk.StringVar()
    #search_cafe_var.trace_add("write", lambda *args: filter_and_display_cafes(search_cafe_var.get()))
    search_cafe_entry = tk.Entry(cafe_frame, textvariable=search_cafe_var)
    search_cafe_entry.pack()

    # 플레이스홀더 추가 및 검색 함수 연결
    add_placeholder_cafe(search_cafe_entry, "카페 검색", lambda: filter_and_display_cafes(search_cafe_var.get()))

    # Create the container frame
    serial_frame = tk.Frame(cafe_frame)
    serial_frame.pack(fill="both")

    # Create the Listbox within the container frame
    cafe_listbox = tk.Listbox(serial_frame)
    cafe_listbox.pack(side="left", fill="both", expand=True)

    # Create the Scrollbar and attach it to the container frame
    serial_scrollbar = tk.Scrollbar(serial_frame, orient="vertical", command=cafe_listbox.yview)
    serial_scrollbar.pack(side="right", fill="y")

    # Configure the Listbox to use the Scrollbar
    cafe_listbox.config(yscrollcommand=serial_scrollbar.set)

    select_cafe_button = tk.Button(cafe_frame, text="카페 선택", command=on_cafe_select_and_update_treeview)
    select_cafe_button.pack()

    select_all_var = tk.IntVar(value=0)
    select_all_checkbox = tk.Checkbutton(cafe_frame, text="전체 선택", variable=select_all_var, onvalue=1, offvalue=0, command=all_cafe_select)
    select_all_checkbox.pack()

    tk.Label(cafe_frame).pack()

    
    # 검색 입력 필드와 변수 바인딩
    search_board_var = tk.StringVar()
    #search_board_var.trace_add("write", lambda *args: filter_and_display_boards(search_board_var.get()))
    search_board_entry = tk.Entry(cafe_frame, textvariable=search_board_var)
    search_board_entry.pack()

    # 플레이스홀더 추가 및 검색 함수 연결
    add_placeholder_board(search_board_entry, "게시판 검색", lambda: filter_and_display_boards(search_board_var.get()))

    board_combobox = ttk.Combobox(cafe_frame, height = 10)
    board_combobox.pack()

    # 버튼 배치를 위한 buttons_frame 정의
    buttons_frame = tk.Frame(cafe_frame)
    buttons_frame.pack()

    post_button = tk.Button(buttons_frame, text="글게시판 선택", command=handle_post_button_click)
    post_button.pack(side="left")

    review_button = tk.Button(buttons_frame, text="댓글게시판 선택", command=handle_review_button_click)
    review_button.pack(side="right")
    

    # 새로운 프레임 정의 및 버튼 배치
    load_buttons_frame = tk.Frame(cafe_frame)
    load_buttons_frame.pack()

    post_contents_button = tk.Button(load_buttons_frame, text="게시글 불러오기", command=load_post_contents, width=20, height=2)
    post_contents_button.pack(side=tk.TOP, fill=tk.X, expand=True, pady=10)
    post_contents_label = tk.Label(load_buttons_frame, text="선택된 폴더 없음")
    post_contents_label.pack()

    comment_contents_button = tk.Button(load_buttons_frame, text="댓글 불러오기", command=load_comment_contents, width=20, height=2)
    comment_contents_button.pack(side=tk.TOP, fill=tk.X, expand=True, pady=10)
    comment_contents_label = tk.Label(load_buttons_frame, text="선택된 폴더 없음")
    comment_contents_label.pack()

    # Tkinter의 버튼 클릭 이벤트를 수정합니다.
    action_button = tk.Button(frame_left, text="실행", command=lambda: run_main_in_thread(cafe_post_file_path.get(), review_file_path.get(), user_id.get(), user_pw.get()))
    action_button.pack(side=tk.TOP, fill=tk.X, expand=True)

    # # 스핀박스를 포함할 프레임
    # spinbox_frame = tk.Frame(root)
    # spinbox_frame.pack(fill=tk.X)

    data_frame = ttk.LabelFrame(frame_right, text="작업리스트")
    data_frame.pack(fill=tk.BOTH,padx=10, pady=15,expand=True)

    tree_frame = tk.Frame(data_frame, height=25)  # 여기서 height 값을 설정
    tree_frame.pack_propagate(False)  # Frame 내부 위젯의 크기 변화를 Frame 크기에 영향을 미치지 않도록 설정
    tree_frame.pack(fill="both", expand=True)

    # Create the Treeview within the tree_frame
    tree = ttk.Treeview(tree_frame, show='headings', height=15)
    add_columns_with_spinboxes(tree)  # Assuming this function sets up the treeview columns
    tree.pack(side='left', fill='both', expand=True, padx=5)

    # Create the Scrollbar within the tree_frame
    scrollbar = ttk.Scrollbar(tree_frame, orient='vertical', command=tree.yview)
    scrollbar.pack(side='right', fill='y')

    # Link the scrollbar to the treeview
    tree.config(yscrollcommand=scrollbar.set)

    tk.Label(frame_right).pack()

    # Create the container frame
    option_frame = tk.Frame(data_frame)
    option_frame.pack()

    menu_button = tk.Button(option_frame, text="게시판 찾기", command=on_cafe_select)
    menu_button.pack(side="left", padx=30)


    visit_count_entry = tk.Entry(option_frame, width=5)
    visit_count_entry.pack(side="left", padx=5)
    
    add_placeholder_to(visit_count_entry, "방문수")

    comment_count_entry = tk.Entry(option_frame, width=5)
    comment_count_entry.pack(side="left", padx=5)
    add_placeholder_to(comment_count_entry, "댓글수")

    post_count_entry = tk.Entry(option_frame, width=7)
    post_count_entry.pack(side="left", padx=5)
    add_placeholder_to(post_count_entry, "게시글수")

    delay_time_entry = tk.Entry(option_frame, width=8)
    delay_time_entry.pack(side="left", padx=5)
    add_placeholder_to(delay_time_entry, "딜레이(분)")

    update_all_button = tk.Button(option_frame, text="전체 업데이트", command=update_all_rows_with_entry_values)
    update_all_button.pack(side="left", padx=10)

    # 삭제 버튼 옆에 저장 버튼 및 불러오기 버튼 추가
    save_button = tk.Button(option_frame, text="데이터 저장", command=save_treeview_data)
    save_button.pack(side="right", padx=5)

    load_button = tk.Button(option_frame, text="데이터 불러오기", command=load_treeview_data)
    load_button.pack(side="right", padx=5)

    # 삭제 및 전체삭제 버튼 사이의 공백을 위한 빈 Frame 생성
    spacer_frame_1 = tk.Frame(option_frame, width=20, height=10)
    spacer_frame_1.pack(side="right", padx=5, fill="both", expand=True)

    # 삭제 버튼 생성 및 이벤트 연결
    all_delete_button = tk.Button(option_frame, text="전체삭제", command=all_delete_selected_item)
    all_delete_button.pack(side="right", padx=5)

    # 삭제 버튼 생성 및 이벤트 연결
    delete_button = tk.Button(option_frame, text="삭제", command=delete_selected_item)
    delete_button.pack(side="right", padx=5)
    # 삭제 및 전체삭제 버튼 사이의 공백을 위한 빈 Frame 생성
    spacer_frame_1 = tk.Frame(option_frame, width=20, height=10)
    spacer_frame_1.pack(side="right", padx=5, fill="both", expand=True)

    # #진행바넣기
    
    # # 프로그레스바 생성 및 설정
    # progressbar = ttk.Progressbar(root, orient="horizontal", length=300, mode="determinate")
    # progressbar.pack(pady=20)

    
    # def update_progressbar(progressbar, delay_time):
    #     """프로그레스바를 업데이트하는 함수"""
    #     max_value = delay_time * 60  # 딜레이 시간을 초 단위로 변환
    #     progressbar['maximum'] = max_value
    #     for i in range(max_value):
    #         time.sleep(1)  # 1초 딜레이
    #         progressbar['value'] = i+1  # 프로그레스바 값을 업데이트
    #         progressbar.update()  # GUI를 업데이트
    #     progressbar['value'] = 0  # 프로그레스바를 리셋


    # # 프로그레스바 업데이트 시작
    # update_progressbar(progressbar, delay_time)

    text_frame = ttk.LabelFrame(frame_right, text="로그")
    text_frame.pack(fill=tk.BOTH, padx=10, pady=10,expand=True)


    # 텍스트 창 추가
    text_area = tk.Text(text_frame, height=5)  # 텍스트 창의 높이 설정
    text_area.pack(fill=tk.BOTH, padx=10, pady=10, expand=True)
    tk.Label(frame_right).pack()

    root.mainloop()


# if __name__ == "__main__":
#     main()
